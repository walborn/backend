# Создание сессий
Когда в приложении появляются приватные данные, то возникает потребность в аутентификации и авторизации

> Авторизация часто считается синонимом аутентификации, но в нашем случае это не так
> Сначала мы проводим аутентификацию, когда проверяем, есть ли токен в системе. Система говорит - "Да это же наш Вася! Привет, Вася!"
> Дальше мы его авторизуем, то есть говорим, что у данного пользователя есть определенные права на выполнение каких либо действий. Ты, Вася, можешь только читать книгу, но тебе нельзя ее дописывать.

В нашем случае приватными данными является список зарегестрированных пользователей. Для получения его, нужно сообщить бэкенду свой емейл и пароль. Бэкенд проверит, есть ли такой пользователь в хранилище, и если найдет, то даст разрешение к приватным данным. 
```
email + password
```

> email + password

Можно было бы сохранить эту пару (емейл + пароль) в браузере и с каждым запросом передавать ее. Но это сильно облегчает работу хакерам, которые смогут перехвать эти данные. Учитывая, что часто пользователи используют один и тот же пароль в разных системах, это может дать хакерам доступ к кошельку, почте и другим сервисам.

> Простой token
```js
{ [token]: uid }
```
Поэтому древние программисты подумали и решили, а давайте генерировать специальный токен и возвращать пользователю после авторизации. Он записывается в хранилище, как ключ, со значением - id пользователя. Теперь при каждом запросе пользователь передает не свою почту-пароль, а только этот ключ и не боится за свои оригинальные пароли.

В принципе, это уже хорошо. Но такой ключ тоже могут украсть и получить полный доступ к приложению. Но настоящий пароль он не узнает.

Чтобы украденным токеном нельзя было пользоваться вечно мы можем ограничить время его жизни. Через определенное время пользователь не сможет получать данные и ему придется перелогиниться. Но пользователь не хочет, чтобы его выкидвало через какое-то время, даже если оно достаточно большое. В таком случае можно выдавать ему каждый раз новый ключ, с обновленным временем жизни. Это отличная идея, потому что если ключ украдут и воспользуются им, то ключ пользователя перестанет быть валидным и он поймет, что его взломали. Все, что ему нужно - это найти безопасное соединение и залогиниться снова.

Однако, такой подход сильно увеличит нагрузку на сервис, да и что делать с параллельными запросами.

> JWT: Access + Refresh
И тут на помощь приходит JWT.

JWT стал стандартом де-факто для сессий. Суть его в том, что мы определенным образом создаем токены доступа, которые используются для проверки подлинности пользователя. 

Работает он так же. Сервер аутентификации генерирует и выдает нам токен доступа, с помощью которого мы сможем ходить в API. У него также будет ограниченное время жизни, но обновляться он умеет автоматически, без перелогинивания. Для этого выдается второй ключ, который называется Refresh токеном. Когда мы не смогли получить данные по токену доступа, то есть сервер ответит ошибкой `token expired`, в ход идет Refresh токен, с помощью которого мы получим два новеньких Access + Refresh токена. И все повторяется.

Основное преимущество такого подхода - автономность токена доступа. Сервис ресурсов умеет проверять его без сервиса аутентификации, то есть для его проверки не требуется хранить записи валидных токенов доступа в хранилище - нужно знать один единственный ключ (секретный или публичный, в зависимости от выбора метода шифрования), с помощью которого можно подписывать тело токена и сравнить подписи.

Но Refresh токены мы храним - фактически это и есть те сессии, которые обновляются при каждом запросе.

То есть токен доступа у нас многоразовый, но короткоживущий. А Refresh токен живет долго, но его можно использовать только один раз.

В следующем видео мы разберемся подробнее, что из себя представляет JWT токен


- [Введение](./0.intro.md)
- [Сессии](./1.sessions.md)
- [JWT](./2.jwt.md)
