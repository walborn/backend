1. Создание сессий
   - Сервер, на котором нарисован знак секретности (top secret) (don't edit)
   - Определение авторизации
   - Затем появляется определение аутентификации
   - Форма авторизации, которая заполняется динамически
   - Показывается, как формируется запрос, в котором отправляется пара каждый раз
   - То же самое, но только теперь показан ключ (туда - кредентиалс, назад - ключ в ответе) А в следующий раз уже ходим с ключем
   - Показать ниндзю, который ворует ключ и ходит в АПИ параллельно с настоящим пользователем
   - Показать, случай, когда ключ каждый раз генерируется новый, а старый превращается в ржавый или сломанный
   -  Если отправим несколько запросов одновременно (напрмер, три), то после выполнения первого, остальные превращаются в сломанные

2. JWT
   - JWT -> J   W   T -> JSON Web Token
   - Два ключа: Access + Refresh
   - Показываем, что с помощью токена доступа мы ходим в базу данных, причем без необходимости обращаться в сервер аутентификации! (крестик на связи с Auth Server)
   - Когда токен истекает (нам приходит ошибка 401 с сервера), то мы сначала выполняем запрос с рефрешем на обновление ключей, а затем возобновляем очередь запросов, начиная с того, который не удался
   - Таблица
   Token       T        N
   ---------------------------
   Access    30 min     ∞
   Refresh   1 month    1
   - можно для затравки показать анатомию JWT токена



# Создание сессий
Как только в приложении появляются приватные данные или потребность их изменять, возникает необходимость в аутентификации и авторизации

> Авторизация часто считается синонимом аутентификации, но в нашем случае это не так
> Сначала мы проводим аутентификацию, то есть проверяем, есть ли токен в системе. Система говорит - "Да это же наш Вася! Привет, Вася!"
> Затем мы его авторизуем, то есть определяем, какие ему доступны возможности. Ты, Вася, можешь только читать статью Пети, но тебе нельзя ее редактировать.

В нашем случае приватными данными является список зарегестрированных пользователей. Чтобы получить доступ мы должны сначала зарегистрироваться, если еще не сделали этого, а потом уже войти с приложение, указав свой емейл и пароль. Бэкенд проверит, есть ли такой пользователь в хранилище, и если есть, то выдаст соотвествующие разрешения на просмотр, редактирование и т. д. 

```
email + password
```

> email + password

Делается это при каждом запросе, именно поэтому вместе с запросом бэк должен получать еще какую-то информацию, что этот запрос от того, кого надо и его можно выполнить.

Первое, что приходит в голову - после авторизации сохранить пару (емейл + пароль) в браузере и с каждым запросом передавать ее. Но любой, кто перехватит запрос, сможет вытащить оттуда емейл и пароль и воспользоваться ими в своих целях. Учитывая, как часто пользователи используют один и тот же пароль в разных системах, это может дать хакерам доступ к кошельку, почте и другим сервисам.

> Простой token
```js
{ [token]: uid }
```
Поэтому древние мохнатые программисты думали, думали и решили - а давайте генерировать специальный токен и возвращать пользователю при успешной авторизации. Он записывается в базу данных, как ключ-значение - <id пользователя>: <token>. И теперь при каждом запросе пользователь передает не свою почту-пароль, а только полученный ключ и не боится за свой любимый пароль.

В принципе, это уже хорошо. Но такой ключ тоже могут украсть и получить полный доступ к приложению. Однако, настоящий пароль никто не узнает и это уже лучше.

### Что делать, если токен украдут?

Чтобы украденным токеном нельзя было пользоваться вечно, можно ограничить время его жизни. Через определенное время пользователь не сможет получать данные и ему придется перелогиниться. Но пользователь не хочет, чтобы его выкидвало через какое-то время, даже если оно достаточно большое.

В таком случае можно выдавать ему каждый раз новый ключ, с обновленным временем жизни. Это отличная идея, потому что если ключ украдут и воспользуются им, то старый ключ, который есть у настоящего пользователя, превратится в тыкву и он при следующем запросе сразу поймет, что его взломали. Все, что ему нужно - это найти безопасное соединение и залогиниться снова.

Однако, такой подход сильно увеличит нагрузку на сервис, да и что делать в случае, когда к API идет сразу несколько запросов одновременно?


# JWT: Access + Refresh
И тут на помощь приходит JWT.

JWT стал стандартом де-факто для сессий. Суть его в том, что мы определенным образом создаем токены доступа, которые используются для проверки подлинности пользователя. 

Сначала все происходит так же - сервер аутентификации генерирует нам токен доступа, с помощью которого мы будем ходить в API. У него тоже будет ограничение по времени жизни, но обновляться он будет сам, автоматически, без перелогинивания. Для этого выдается второй ключ, который называется Refresh токеном. Когда мы не смогли получить данные по токену доступа, то есть сервер ответит ошибкой `token expired`, в ход идет Refresh токен, с помощью которого мы получим два новеньких Access + Refresh токена. И все повторяется.

Это все можно реализовать и без JWT. Зачем же он нам тогда нужен. А дело в том, что для JWT нам больше не нужно хранить токен доступа в базе, поскольку любой, кто знает определенный ключ (приватный или публичный, в зависимости от выбора метода шифрования), сможет понять, является ли токен корректным. Но Refresh токены всё-таки потребуют хранить себя где-нибудь, фактически - это те же самые сессии, которые обновлялись при каждом запросе, но теперь они это делают только при определенном запросе, который приостанавливает все предыдущие запросы, которые не успели выполниться.

Отсюда мы получаем главное преимущество такого подхода - автономность токена доступа. Нам все еще придется хранить Refresh токены, но обновлять их придется довольно редко. Чем выше мы хотим обеспечить секьюрность, тем короче должен жить токен доступа.

Таким образом, токен доступа у нас многоразовый, но короткоживущий. А Refresh токен можно использовать только один раз, но живет он долго.
Обычно, токен доступа живет порядка 30 минут, а рефреш токен - месяц, год

В следующем видео мы разберемся подробнее, что из себя представляет JWT токен


- [Введение](./0.intro.md)
- [Сессии](./1.sessions.md)
- [JWT](./2.jwt.md)
