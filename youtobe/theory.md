# Intro

-> О чем этот скринкаст?
-> Создание сессий на JWT. Теория
-> Создание API на NodeJS + Mongoose
-> Содание приложения на ReactJS
-> Постановка задачи

Всем привет! Добро пожаловать на скринкаст по созданию полноценного приложения с базовой авторизацией.

В нем мы познакомимся с созданием сессий на JWT. Я дам вам всю необходимую теорию для понимания того, как все работает, и расскажу плюсы и минусы различных подходов.

Затем мы напишем свой собственный API на NodeJS и Mongoose. Будем пользоваться автотестами на Jest для наглядности.

И в конце создадим приложение на ReactJS для подключения к нашему API.


В целях обучения я намеренно упростил задачу. У нас не будет никаких дополнительных сущностей, кроме самого пользователя. Он у нас должен уметь регистрироваться, авторизоваться и получать список пользователей, если он авторизован.

Итак, поехали!

# JSON Web Token

JWT стал стандартом де-факто для сессий. Суть его в том, что мы определенным образом создаем токены доступа, которые используются для проверки подлинности пользователя. 

Для чего это нужно? 
Допустим, у нас есть приватные данные. В нашем случае - это список зарегестрированных пользователей. Для получения его, нужно сообщить бэкенду свой емейл и пароль. Бэкенд проверит, есть ли такой пользователь в хранилище, и если есть то даст разрешение к приватным данным.
```
email + password
```
Можно было бы сохранить эту пару (емейл + пароль) в браузере и с каждым запросом передавать ее. Но это сильно облегчает работу хакерам, которые смогут перехвать эти данные. Учитывая, что часто пользователи используют один и тот же пароль от разных систем - это может дать хакерам доступ к кошельку, к почте и другим сервисам.

```js
{ [token]: uid }
```
Поэтому древние программисты подумали и решили, а давайте генерировать специальный токен и возвращать пользователю после авторизации. Он записывается в хранилище, как ключ, со значением ID пользователя. Теперь при каждом запросе пользователь передает не свою почту-пароль, а только этот ключ и не боится за свои оригинальные пароли.

В принципе, это уже хорошо. Но такой ключ тоже может быть украден. Хоть на этот раз хакер и не узнает настоящий пароль, но к данному приложению получит бесконечный доступ.

В таком случае мы могли бы установить время жизни токена, по истечении которого придется снова авторизоваться. Но пользователь не хочет, чтобы его выкидвало через какое-то, даже достаточно большое, время. В таком случае можно выдавать ему каждый раз новый ключ, с обновленным временем жизни. Это отличная идея, потому что если ключ украдут и воспользуются им, то пользователя выкинет из системы при его попытке входа - появится подозрение, что его взломали.

Однако, это сильно увеличит нагрузку на сервис, да и что делать с параллельными запросами - мы не сможем выполнять их параллельно.

И тут приходит на помощь JWT.


## JWT

Работает он так же. Сервер аутентификации генерирует и выдает нам токен доступа, то есть JWT, с помощью которого мы сможем ходить в API. Но до тех пор, пока не истечет его время жизни. Но для того, чтобы он умел автоматически обновляться, выдается второй ключ, который называется Refresh токен. Когда токен доступа протухает, то сервер ответит ошибкой "token expired". В этом случае в ход идет Refresh, который вернет от бэкенда два новеньких Access + Refresh токена. И мы сможем снова какое-то время ходить с токеном доступа.

Основное преимущество такого подхода - автономность токена доступа. Сервис умеет проверять его без сервиса аутентификации, то есть для его проверки не требуется хранить записи валидных токенов доступа в хранилище - нужно знать один единственный ключ (секретный или публичный, в зависимости от выбора метода шифрования), с помощью которого можно подписывать тело токена и сравнивать подписи.

Но Refresh токены храни

Второе преимущество появляется, когда мы используем связку токенов - Refresh + Access. Acceess token - это наш JWT, а Refresh - обыный токен с временем жизни. То есть это те же сессии, но мы не делаем запросы к хранилищу при каждом запросе, а лишь тогда, когда время жизни нашего токена доступа истекло. Практически, это доработанный вариант нашего последнего решения, который берет лучшее от каждого из двух подходов.

Теперь, когда стало все ясно, разберемся, что из себя представляет этот зверь, JWT токен

### Структура

*JWT* состоит из трех частей: заголовок `header`, полезные данные `payload` и подпись `signature`

`token = header.payload.signature` 

##### Заголовок (header)

Cодержит информацию об используемом алгоритме хэширования для создания подписи. Обычно это либо симметричный способ шифрования HS256 или ассиметричный RS256 с двумя ключами - публичным и приватным. Приватный ключ создает подпись, а публичный проверяет его на подлинность, то есть даже если он попадет к злоумышленнику, он ему будет абсолютно бесполезен.

```js
header = { alg: 'HS256', typ: 'JWT'}
```

##### Полезная нагрузка (payload)

Содержит полезные нам данные, которые могут пригодиться приложению. Эти данные называются заявками и могут быть какими угодно. 

```js
payload = { uid: 'b08f86af-35da-48f2-8fab-cef3904660bd', exp: '1593540266' }
```

Здесь мы положили только две *заявки*: *id* пользователя и время жизни токена. Существует список зарезервированных ключей (ссылка в описании), из которых наибольший интерес представляет ключ *exp* (expiration time) — время жизни токена в формате unix - количества секунд, прошедших с начала 1 января 1970 года.

(https://tools.ietf.org/html/rfc7519#section-4.1) [Wiki](https://en.wikipedia.org/wiki/JSON_Web_Token#Standard_fields)

##### Signature

Криптографическая подпись - самая важная часть токена, ради которой все и создавалось. Она состоит из зашифрованных ключом заголовка и полезной нагрузки. Таким образом, если предыдущие части можно подменить - по сути это открытые данные, т.к. base64 - это не криптография. То подделать подпись, не зная секретного ключа, невозможно.

1. Сначала мы кодируем header и payload с помощью алгоритма base64
2. Соединяем закодированные части через точку
3. Применяем алгоритм HMAC-SHA256 над полученной строкой и секретным ключом
4. Склеиваем все три части через точку - это и будет наш JWT токен

```js
base64(header)  base64(payload)

`${base64(header)}.${base64(payload)}`
signature = HS256 -> HMAC-SHA256(`${base64(header)}.${base64(payload)}` - unsigned, 'cAtwa1kkEy' -> SECRET_KEY)

// header eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9
// payload eyJ1c2VySWQiOiJiMDhmODZhZi0zNWRhLTQ4ZjItOGZhYi1jZWYzOTA0NjYwYmQifQ
// signature -xN_h82PHVTCMA9vdoHrcZxH-x5mb11y1537t3rGzcM
```

```js
const token = `${base64(header)}.${base64(payload)}.${base64(signature)}
// JWT Access Token
// eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VySWQiOiJiMDhmODZhZi0zNWRhLTQ4ZjItOGZhYi1jZWYzOTA0NjYwYmQifQ.-xN_h82PHVTCMA9vdoHrcZxH-x5mb11y1537t3rGzcM
```

Вы можете попробовать создать свой собственный *JWT* на сайте [jwt.io](https://jwt.io/) или проверить токен из описания.

### Как JWT защищает наши данные?



Очень важно понимать, что использование *JWT* **НЕ** скрывает и не маскирует данные автоматически. Причина, почему *JWT* используются — это проверка, что отправленные данные были действительно отправлены авторизованным источником. Как было продемонстрировано выше, данные внутри *JWT* закодированы и подписаны, обратите внимание, это не одно и тоже, что зашифрованы. Цель кодирования данных — преобразование структуры. Подписанные данные позволяют получателю данных проверить аутентификацию источника данных. Таким образом закодирование и подпись данных не защищает их. С другой стороны, главная цель шифрования — это защита данных от неавторизованного доступа. Для более детального объяснения различия между кодированием и шифрованием, а также о том, как работает хеширование, смотрите [эту статью](https://danielmiessler.com/study/encoding-encryption-hashing-obfuscation/#encoding). Поскольку *JWT* только лишь закодирована и подписана, и поскольку *JWT* не зашифрована, *JWT* не гарантирует никакой безопасности для чувствительных *(sensitive)* данных.



### Шаг 5. Проверка JWT



В нашем простом примере из 3 участников мы используем *JWT*, который подписан с помощью `HS256` алгоритма и только сервер аутентификации и сервер приложения знают секретный ключ. Сервер приложения получает секретный ключ от сервера аутентификации во время установки аутентификационных процессов. Поскольку приложение знает секретный ключ, когда пользователь делает API-запрос с приложенным к нему токеном, приложение может выполнить тот же алгоритм подписывания к *JWT*, что в шаге *3*. Приложение может потом проверить эту подпись, сравнивая ее со своей собственной, вычисленной хешированием. Если подписи совпадают, значит *JWT* валидный, т.е. пришел от проверенного источника. Если подписи не совпадают, значит что-то пошло не так — возможно, это является признаком потенциальной атаки. Таким образом, проверяя *JWT*, приложение добавляет доверительный слой *(a layer of trust)* между собой и пользователем.



## В заключение



Мы прошлись по тому, что такое *JWT*, как они создаются и как валидируются, каким образом они могут быть использованы для установления доверительных отношений между пользователем и приложением. Но это лишь кусочек пазла большой темы авторизации и обеспечения защиты вашего приложения. Мы рассмотрели лишь основы, но без них невозможно двигаться дальше.



## Что дальше?



Подумаем о безопасности и добавим `Refresh Token`. Смотрите следующую мою [статью на эту тему](https://habr.com/ru/post/466929/).

https://habr.com/ru/post/340146/

https://habr.com/ru/company/acribia/blog/457090/

https://gist.github.com/zmts/802dc9c3510d79fd40f9dc38a12bccfc

2 часть Проблемы

https://qna.habr.com/q/338861

OAuth2 https://habr.com/ru/company/flant/blog/475942/



NextJS https://medium.com/@anMagpie/next-js-jwt-auth-example-app-4ea4d7f49fa3

https://www.jaygould.co.uk/2020-01-31-nextjs-auth-jwt-context-hooks/


## Задача

Представим такую ситуацию.

Вы - крутой разработчик и вас попросили написать приложение с защищенным доступом. Отказать вы не можете - вы же крутой разраб. Поэтому вы начинаете думать.

А пока вы думаете, заказчик дополняет описание

Я хочу, чтобы любой пользователь Вася мог открыть форму регистрации, вбить свою почту и пароль, зарегистрироваться и дальше входить в приложение через форму авторизации с этими почтой-паролем. Авторизованным пользователям открывается доступ на страницу списка авторизованных пользователей.

Итак, вы декомпозировали задачу и начать нужно с того, чтобы написать логику авторизации. Как это сделать!?

## Предыстория

Первое, что может прийти в голову - а давайте при каждом запросе пользователь будет передавать нам свой email+password. И это будет отлично работать... в идеальном мире, где розовые единороги и все друг другу братья. В нашем мире, к сожалению не все так радужно и существуют злые хакеры, которые не прочь завладеть нашими паролями, чтобы получить доступ к вашей личной информации или опустошить ваш онлайн-кошелек. Если мы используем незащищенный протокол, то эти сможет отловить разве что не ленивый. С защищенным протоколом дела обстоят лучше, но и в таком случае есть вероятность утечки (объяснить) 

Поэтому древние программисты подумали, подумали и изобрели сессии. После того, как пользователь передает свой email+password серверу аутентификации, на нем генерируется случайное число (или не случайное), то есть токен, для которого создается запись ` { [token]: uid }` Этот токен возвращается пользователю в теле ответа. И теперь с этим токином пользователь может получать все, что нужно. А сервер каждый раз ищет соответствующую запись в хранилище и если, вдруг, там ее нет, то кричит 401й - ты не авторизован!

Однако, если злой хакер сворует такой токен, то сможет пользоваться им вечно! Поэтому такому токену часто устанавливают конечное время жизни, но все равно оно должно быть достаточно продолжительным, чтобы пользователя постоянно не выкидывало и не требовало снова вводить свои секретные данные. Помимо праведного негодования это еще не безопасно, так как мало отличается от случая, когда передается почта-пароль каждый раз.

Если мы будем каждый раз создавать новый токен с продленным временем жизни, то это частично решит проблему, но сильно увеличит нагрузку на сервер.


<!-- С помощью JWT можно создавать сессии. Он даже считается стандартом де-факто.


Но мало кто хорошо разбирается в нем, поэтому я решил рассказать об этом подробнее. Надеюсь, это видео будет для вас полезным.

В нем я расскажу о способах создания сессий. Рассмотрим основные подходы и разберем, какими достоинствами и недостатками обладает каждый из них.

Расскажем подробнее, как устроен сам JWT, из каких частей он состоит и насколько он может быть полезен



Существуют различные подходы для организации сессий. JWT является одним из таких подходов.

JWT стал стандартом де-факто для сессий. Суть его в том, что мы определенным образом создаем токены доступа, которые используются для проверки подлинности пользователя в клиент-серверных приложениях. 

 но не все достаточно хорошо разбираются в этой технологии, поэтому я решил познакомить вас подробнее, а заодно заставить немного подумать.

Надеюсь это видео будет для вас полезным.



Сначала я расскажу небольшую теорию о том, какие идеи привели к созданию такого подхода, из чего он состоит, его сильные стороны, недостатки и способы их обойти.

Затем мы создадим полноценное REST API с аутентификацией на NodeJS + Mongoose

И подключимся к нему через веб приложение на ReactJS

Итак, поехали! -->