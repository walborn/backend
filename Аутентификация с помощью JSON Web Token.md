# Аутентификация с помощью JSON Web Token



stateless - клиент сам заботится о своей аутентификации при каждом запросе

Что такое JWT токен и чем его едят

Всем привет! Добро пожаловать на скринкаст по JWT -  JSON Web Токенам. Они стали стандартом де-факто для авторизации, но не все достаточно хорошо разбираются в этой технологии, поэтому я решил познакомить вас подробнее, а заодно заставить немного подумать.

Надеюсь это видео будет для вас полезным.



Сначала я расскажу небольшую теорию о том, какие идеи привели к созданию такого подхода, из чего он состоит, его сильные стороны, недостатки и способы их обойти.

Затем мы создадим полноценное REST API с аутентификацией на NodeJS + Mongoose

И подключимся к нему через веб приложение на ReactJS

Итак, поехали!



## Задача

Представим такую ситуацию.

Вы - крутой разработчик и вас попросили написать приложение с защищенным доступом. Отказать вы не можете - вы же крутой разраб. Поэтому вы начинаете думать.

А пока вы думаете, заказчик дополняет описание

Я хочу, чтобы любой пользователь Вася мог открыть форму регистрации, вбить свою почту и пароль, зарегистрироваться и дальше входить в приложение через форму авторизации с этими почтой-паролем. Авторизованным пользователям открывается доступ на страницу списка авторизованных пользователей.

Итак, вы декомпозировали задачу и начать нужно с того, чтобы написать логику авторизации. Как это сделать!?

## Предыстория

Первое, что может прийти в голову - а давайте при каждом запросе пользователь будет передавать нам свой email+password. И это будет отлично работать... в идеальном мире, где розовые единороги и все друг другу братья. В нашем мире, к сожалению не все так радужно и существуют злые хакеры, которые не прочь завладеть нашими паролями, чтобы получить доступ к вашей личной информации или опустошить ваш онлайн-кошелек. Если мы используем незащищенный протокол, то эти сможет отловить разве что не ленивый. С защищенным протоколом дела обстоят лучше, но и в таком случае есть вероятность утечки (объяснить) 

Поэтому древние программисты подумали, подумали и изобрели сессии. После того, как пользователь передает свой email+password серверу аутентификации, на нем генерируется случайное число (или не случайное), то есть токен, для которого создается запись ` { [token]: uid }` Этот токен возвращается пользователю в теле ответа. И теперь с этим токином пользователь может получать все, что нужно. А сервер каждый раз ищет соответствующую запись в хранилище и если, вдруг, там ее нет, то кричит 401й - ты не авторизован!

Однако, если злой хакер сворует такой токен, то сможет пользоваться им вечно! Поэтому такому токену часто устанавливают конечное время жизни, но все равно оно должно быть достаточно продолжительным, чтобы пользователя постоянно не выкидывало и не требовало снова вводить свои секретные данные. Помимо праведного негодования это еще не безопасно, так как мало отличается от случая, когда передается почта-пароль каждый раз.

Если мы будем каждый раз создавать новый токен с продленным временем жизни, то это частично решит проблему, но сильно увеличит нагрузку на сервер.

## JWT

И вот, вы услышали про такую технологию, как JSON Web Token. Эта штука решает ту же проблему, но более эффективно с точки зрения нагрузки. Однако, у него тоже есть недостатки, но о них мы поговорим в следующем видео.

Работает он так же. Сервер аутентификации генерирует и выдает нам JWT токен, с помощью которого мы сможем ходить в API. Но до тех пор, пока не истечет его время жизни. Пользователь для себя не увидит никакой разницы, а вся магия будет происходить внутри приложения.

Основное преимущество - это его автономность. То есть для его проверки не требуется хранить записи валидных токенов в хранилище - нужно знать только ключ (секретный или публичный, в зависимости от выбора метода шифрования)

Второе преимущество появляется, когда мы используем связку токенов - Refresh + Access. Acceess token - это наш JWT, а Refresh - обыный токен с временем жизни. То есть это те же сессии, но мы не делаем запросы к хранилищу при каждом запросе, а лишь тогда, когда время жизни нашего токена доступа истекло. Практически, это доработанный вариант нашего последнего решения, который берет лучшее от каждого из двух подходов.

Теперь, когда стало все ясно, разберемся, что из себя представляет этот зверь, JWT токен

### Структура

*JWT* состоит из трех частей: заголовок `header`, полезные данные `payload` и подпись `signature`

`token = header.payload.signature` 

##### Заголовок (header)

Cодержит информацию об используемом алгоритме хэширования для создания подписи. Обычно это либо симметричный способ шифрования HS256 или ассиметричный RS256 с двумя ключами - публичным и приватным. Приватный ключ создает подпись, а публичный проверяет его на подлинность, то есть даже если он попадет к злоумышленнику, он ему будет абсолютно бесполезен.

```js
header = { alg: 'HS256', typ: 'JWT'}
```

##### Полезная нагрузка (payload)

Содержит полезные нам данные, которые могут пригодиться приложению. Эти данные называются заявками и могут быть какими угодно. 

```js
payload = { uid: 'b08f86af-35da-48f2-8fab-cef3904660bd', exp: '1593540266' }
```

Здесь мы положили только две *заявки*: *id* пользователя и время жизни токена. Существует список зарезервированных ключей (ссылка в описании), из которых наибольший интерес представляет ключ *exp* (expiration time) — время жизни токена в формате unix - количества секунд, прошедших с начала 1 января 1970 года.

(https://tools.ietf.org/html/rfc7519#section-4.1) [Wiki](https://en.wikipedia.org/wiki/JSON_Web_Token#Standard_fields)

##### Signature

Криптографическая подпись - самая важная часть токена, ради которой все и создавалось. Она состоит из зашифрованных ключом заголовка и полезной нагрузки. Таким образом, если предыдущие части можно подменить - по сути это открытые данные, т.к. base64 - это не криптография. То подделать подпись, не зная секретного ключа, невозможно.

1. Сначала мы кодируем header и payload с помощью алгоритма base64
2. Соединяем закодированные части через точку
3. Применяем алгоритм HMAC-SHA256 над полученной строкой и секретным ключом
4. Склеиваем все три части через точку - это и будет наш JWT токен

```js
base64(header)  base64(payload)

`${base64(header)}.${base64(payload)}`
signature = HS256 -> HMAC-SHA256(`${base64(header)}.${base64(payload)}` - unsigned, 'cAtwa1kkEy' -> SECRET_KEY)

// header eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9
// payload eyJ1c2VySWQiOiJiMDhmODZhZi0zNWRhLTQ4ZjItOGZhYi1jZWYzOTA0NjYwYmQifQ
// signature -xN_h82PHVTCMA9vdoHrcZxH-x5mb11y1537t3rGzcM
```

```js
const token = `${base64(header)}.${base64(payload)}.${base64(signature)}
// JWT Access Token
// eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VySWQiOiJiMDhmODZhZi0zNWRhLTQ4ZjItOGZhYi1jZWYzOTA0NjYwYmQifQ.-xN_h82PHVTCMA9vdoHrcZxH-x5mb11y1537t3rGzcM
```

Вы можете попробовать создать свой собственный *JWT* на сайте [jwt.io](https://jwt.io/) или проверить токен из описания.

### Как JWT защищает наши данные?



Очень важно понимать, что использование *JWT* **НЕ** скрывает и не маскирует данные автоматически. Причина, почему *JWT* используются — это проверка, что отправленные данные были действительно отправлены авторизованным источником. Как было продемонстрировано выше, данные внутри *JWT* закодированы и подписаны, обратите внимание, это не одно и тоже, что зашифрованы. Цель кодирования данных — преобразование структуры. Подписанные данные позволяют получателю данных проверить аутентификацию источника данных. Таким образом закодирование и подпись данных не защищает их. С другой стороны, главная цель шифрования — это защита данных от неавторизованного доступа. Для более детального объяснения различия между кодированием и шифрованием, а также о том, как работает хеширование, смотрите [эту статью](https://danielmiessler.com/study/encoding-encryption-hashing-obfuscation/#encoding). Поскольку *JWT* только лишь закодирована и подписана, и поскольку *JWT* не зашифрована, *JWT* не гарантирует никакой безопасности для чувствительных *(sensitive)* данных.



### Шаг 5. Проверка JWT



В нашем простом примере из 3 участников мы используем *JWT*, который подписан с помощью `HS256` алгоритма и только сервер аутентификации и сервер приложения знают секретный ключ. Сервер приложения получает секретный ключ от сервера аутентификации во время установки аутентификационных процессов. Поскольку приложение знает секретный ключ, когда пользователь делает API-запрос с приложенным к нему токеном, приложение может выполнить тот же алгоритм подписывания к *JWT*, что в шаге *3*. Приложение может потом проверить эту подпись, сравнивая ее со своей собственной, вычисленной хешированием. Если подписи совпадают, значит *JWT* валидный, т.е. пришел от проверенного источника. Если подписи не совпадают, значит что-то пошло не так — возможно, это является признаком потенциальной атаки. Таким образом, проверяя *JWT*, приложение добавляет доверительный слой *(a layer of trust)* между собой и пользователем.



## В заключение



Мы прошлись по тому, что такое *JWT*, как они создаются и как валидируются, каким образом они могут быть использованы для установления доверительных отношений между пользователем и приложением. Но это лишь кусочек пазла большой темы авторизации и обеспечения защиты вашего приложения. Мы рассмотрели лишь основы, но без них невозможно двигаться дальше.



## Что дальше?



Подумаем о безопасности и добавим `Refresh Token`. Смотрите следующую мою [статью на эту тему](https://habr.com/ru/post/466929/).

https://habr.com/ru/post/340146/

https://habr.com/ru/company/acribia/blog/457090/

https://gist.github.com/zmts/802dc9c3510d79fd40f9dc38a12bccfc

2 часть Проблемы

https://qna.habr.com/q/338861

OAuth2 https://habr.com/ru/company/flant/blog/475942/



NextJS https://medium.com/@anMagpie/next-js-jwt-auth-example-app-4ea4d7f49fa3

https://www.jaygould.co.uk/2020-01-31-nextjs-auth-jwt-context-hooks/